//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.3

#[cfg(feature = "hal")]
use hypertext_application_language::{
    ext::sea_orm::AsResource,
    link::{AsLink, Link},
    resource::Resource,
};

use sea_orm::{entity::prelude::*, QueryOrder};
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "books")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    #[sea_orm(column_type = "Text")]
    pub title: String,
    #[sea_orm(column_type = "Text", nullable)]
    pub sort: Option<String>,
    pub timestamp: Option<DateTimeUtc>,
    pub pubdate: Option<DateTimeUtc>,
    pub series_index: Decimal,
    #[sea_orm(column_type = "Text", nullable)]
    pub author_sort: Option<String>,
    #[sea_orm(column_type = "Text", nullable)]
    pub isbn: Option<String>,
    #[sea_orm(column_type = "Text", nullable)]
    pub lccn: Option<String>,
    #[sea_orm(column_type = "Text")]
    pub path: String,
    pub flags: i32,
    #[sea_orm(column_type = "Text", nullable)]
    pub uuid: Option<String>,
    #[sea_orm(column_type = "custom(\"BOOL\")", nullable)]
    pub has_cover: Option<bool>,
    pub last_modified: DateTimeUtc,
}

#[derive(Copy, Clone, Debug, EnumIter)]
pub enum Relation {
    Comments,
    Formats,
}

impl RelationTrait for Relation {
    fn def(&self) -> RelationDef {
        match self {
            Self::Comments => Entity::has_many(super::comments::Entity).into(),
            Self::Formats => Entity::has_many(super::data::Entity).into(),
        }
    }
}

impl Related<super::comments::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Comments.def()
    }
}

impl Related<super::data::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Formats.def()
    }
}

impl Related<super::authors::Entity> for Entity {
    fn to() -> RelationDef {
        super::books_authors_link::Relation::Author.def()
    }

    fn via() -> Option<RelationDef> {
        Some(super::books_authors_link::Relation::Book.def().rev())
    }
}

impl Related<super::series::Entity> for Entity {
    fn to() -> RelationDef {
        super::books_series_link::Relation::Series.def()
    }

    fn via() -> Option<RelationDef> {
        Some(super::books_series_link::Relation::Book.def().rev())
    }
}

impl ActiveModelBehavior for ActiveModel {}

impl crate::library::LibraryResource for Model {
    fn path(&self) -> Option<std::path::PathBuf> {
        Some(::std::path::PathBuf::from(&self.path))
    }
}

#[cfg(feature = "hal")]
impl AsLink for Model {
    fn as_link(&self) -> Link {
        self.self_link().with_title(&self.title)
    }
}

#[cfg(feature = "hal")]
impl AsResource for Model {
    fn resource_kind(&self) -> &str {
        Entity.table_name()
    }

    fn resource_identifier(&self) -> impl ::std::fmt::Display {
        self.id.to_string()
    }

    async fn as_resource(
        &self,
        conn: &sea_orm::DatabaseConnection,
    ) -> hypertext_application_language::error::Result<Resource> {
        let mut resource = Resource::from_model::<Entity>(self)?;

        if self.has_cover.unwrap_or(false) {
            resource = resource
                .with_link("cover", self.self_entity_link("cover"))
                .with_link("thumbnail", self.self_entity_link("thumbnail"));
        }

        if let Ok(format) = self
            .find_related(super::data::Entity)
            .order_by_asc(super::data::Column::Format)
            .all(conn)
            .await
        {
            resource = resource.with_links(
                "downloads",
                format.iter().map(|format| {
                    self.self_entity_link(format!("download/{}", format.format.to_lowercase()))
                        .with_name(&format.format)
                }),
            );
        }

        if let Ok(authors) = self
            .find_related(super::authors::Entity)
            .order_by_asc(super::authors::Column::Sort)
            .all(conn)
            .await
        {
            resource = resource.with_links("authors", authors);
        }

        if let Ok(series) = self
            .find_related(super::series::Entity)
            .order_by_asc(super::series::Column::Sort)
            .all(conn)
            .await
        {
            resource = resource.with_links("series", series);
        }

        Ok(resource)
    }
}
